' A part of the GDI+ Package for TwinBasic  https://github.com/kubao/GdiPlus
' Licensed under the MIT license. (c) 2026 Sunderland Ober Consulting.
' "Windows" is a trademark of the Microsoft Corporation.
' Modeled after code and descriptions (c) Microsoft, taken from SDK headers and official documentation.
' Certain flat API function and type declarations taken from WinDevLib by fafalone, with thanks.

[COMCreatable(False)]
Class PathData
    Public pd As GpPathData
    
    Sub New()
    End Sub
    
    Sub New(ByVal count&)
        pd.Allocate(count)
    End Sub
    
    Sub New(points() As TypedPoint)
        pd = GpPathData(points)
    End Sub
    
    Sub New(pathData As GpPathData)
        pd = pathData
    End Sub
    
    Sub Allocate(ByVal Count&)
        pd.Allocate(Count)
    End Sub
    
    Property Get PointsPtr() As LongPtr
        Return pd.Points
    End Property
    
    Property Get TypesPtr() As LongPtr
        Return pd.Types
    End Property
    
    Property Get Count() As Long
        Return pd.count
    End Property
    
    Property Get Point(ByVal index&) As GpPointF
        Return pd.Point(index)
    End Property

    Property Get Type(ByVal index&) As PathPointType
        Return pd.Type(index)
    End Property
        
    Property Get TypedPoint(ByVal index&) As TypedPoint
        Return pd.TypedPoint(index)
    End Property
        
    Property Let Point(ByVal index&, ByVal point As GpPointF)
        pd.Point(index) = point
    End Property

    Property Let Type(ByVal index&, ByVal type As PathPointType)
        pd.Type(index) = type
    End Property
        
    Property Let TypedPoint(ByVal index&, point As TypedPoint)
        pd.TypedPoint(index) = point
    End Property
        
    [Description("Returns a view into the points array." & vbCrLf & _
            "The view is valid only as long as the PathData exists.")]
    Function Points() As GpPointF()
        Return pd.GetPoints()
    End Function
        
    [Description("Returns a view into the types array." & vbCrLf & _
            "The view is valid only as long as the PathData exists")]
    Function Types() As PathPointType()
        Return pd.GetTypes()
    End Function
        
    Function TypedPoints() As TypedPoint()
        Return pd.GetTypedPoints()
    End Function
        
    Sub Class_Terminate()
        pd.Free()
    End Sub
End Class

Module GdipPathData
    Function PathData(ByVal count&) As PathData
        Return New PathData(count)
    End Function
    
    Function PathData(points() As TypedPoint) As PathData
        Return New PathData(points)
    End Function
    
    Function PathData(pd As GpPathData) As PathData
        Return New PathData(pd)
    End Function
    
    [Description("Points and nodes in a Path." & vbCrLf & _
            "This UDT does not manage memory by itself. Allocate() and Free()" & vbCrLf & _
            "must be explicitly invoked. Use the PathData class instead.")]
    Type GpPathData
        count&
        Points As LongPtr ' GpPointF*
        Types As LongPtr  ' PathPointType*
        
        Sub Free()
            GdipFree(Me.Points)
            GdipFree(Me.Types)
            Me.count = 0
            Me.Points = vbNullPtr
            Me.Types = vbNullPtr
        End Sub
        
        Function Allocate(ByVal newCount&) As GpStatus
            Return AllocateArraysInUDT(newCount, LenB(Of GpPointF), Me.Points, LenB(Of PathPointType), Me.Types, Me.count)
        End Function
        
        Property Get Point(ByVal index&) As GpPointF
            If index > 0 And index <= Me.count Then
                Dim src As LongPtr = Me.Points + (index - 1) * LenB(Of GpPointF)
                #If win64 Then
                    GDIP_CopyMemory(Point, ByVal src, 8)
                #Else
                    GetMem8(src, ByVal VarPtr(Point))
                #End If
            End If
        End Property

        Property Get Type(ByVal index&) As PathPointType
            If index > 0 And index <= Me.count Then
                Dim src As LongPtr = Me.Types + (index - 1) * LenB(Of PathPointType)
                GetMem1(src, Type._value)
            End If
        End Property
        
        Property Get TypedPoint(ByVal index&) As TypedPoint
            TypedPoint.pos = Me.Point(index)
            TypedPoint.type = Me.Type(index)
        End Property
        
        Property Let Point(ByVal index&, ByVal point As GpPointF)
            Dim dst As LongPtr = Me.Points + (index - 1) * LenB(Of GpPointF)
            vbaCopyBytesRef(LenB(Of GpPointF), ByVal dst, point)
        End Property

        Property Let Type(ByVal index&, ByVal type As PathPointType)
            Dim dst As LongPtr = Me.Types + (index - 1) * LenB(Of Byte)
            PutMem1(dst, type._value)
        End Property
        
        Property Let TypedPoint(ByVal index&, point As TypedPoint)
            Me.Point(index) = point.pos
            Me.Type(index) = point.type
        End Property
        
        [Description("Returns a view into the points array." & vbCrLf & _
                "The view is valid only as long as the PathData exists.")]
        Function GetPoints() As GpPointF()
            Return GetStaticTrailingSA(Of GpPointF)(Me.Points, Me.count)
        End Function
        
        [Description("Returns a view into the types array." & vbCrLf & _
                "The view is valid only as long as the PathData exists")]
        Function GetTypes() As PathPointType()
            Return GetStaticTrailingSA(Of PathPointType)(Me.Types, Me.count)
        End Function
        
        Function GetTypedPoints() As TypedPoint()
            Dim result() As TypedPoint
            ReDim result(1 To Me.count)
            For i As Long = 1 To Me.count
                result(i).pos = Me.Point(i)
                result(i).type = Me.Type(i)
            Next
            Return result
        End Function
    End Type
    
    Function GpPathData() As GpPathData
    End Function
    
    Function GpPathData(ByVal count&) As GpPathData
        GpPathData.Allocate(count)
    End Function
    
    Function GpPathData(points() As TypedPoint) As GpPathData
        GpPathData.Allocate(ArrayLen(points))
        For i As Long = LBound(points) To UBound(points)
            GpPathData.Point(i) = points(i).pos
            GpPathData.Type(i) = points(i).type
        Next
    End Function
    
    Declare PtrSafe Sub GDIP_CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
End Module
