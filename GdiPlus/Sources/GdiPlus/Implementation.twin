' A part of the GDI+ Package for TwinBasic  https://github.com/kubao/GdiPlus
' Licensed under the MIT license. (c) 2026 Sunderland Ober Consulting.
' "Windows" is a trademark of the Microsoft Corporation.
' Modeled after code and descriptions (c) Microsoft, taken from SDK headers and official documentation.
' Certain flat API function and type declarations taken from WinDevLib by fafalone, with thanks.

Private Module GdipImplementation
    Private Const FADF_STATIC = &H2%
    Private Const FADF_FIXEDSIZE = &H10%

    Function ArrayLen(Of T)(array() As T) As Long
        Return 1 + UBound(array) - LBound(array)
    End Function
    
    Sub SetStaticSA(ByRef sa As GDIP_SAFEARRAY1D, ByVal elementSize&, ByVal data As LongPtr, ByVal count&)
        sa.cDims = 1
        sa.fFeatures = FADF_STATIC + FADF_FIXEDSIZE
        sa.cbElements = elementSize&
        sa.cLocks = 0
        sa.pvData = data
        sa.Bounds.cElements = count
        sa.Bounds.lLbound = 1
    End Sub
    
    Private Sub SetCElements(ByRef sa As GDIP_SAFEARRAY1D, ByVal count&)
        sa.Bounds.cElements = count
    End Sub

    [Description("Returns a static SAFEARRAY1D that refers to data.")]
    Function StaticSA(Of T)(ByVal data As LongPtr, ByVal count&) As T()
        Dim saPtr As LongPtr
        GdipImplementation.SafeArrayAllocDescriptor(1, StaticSA)
        GetMemPtr(VarPtr(StaticSA), saPtr)
        SetStaticSA(ByVal saPtr, LenB(Of T), data, count)
    End Function

    [Description("Redims an array from lbound to ubound." & vbcrlf & _
        "Ensures that total allocated size is at least requiredByteSize.")]
    Sub ReDimOversized(Of T)(array() As T, ByVal lbound&, ByVal ubound&, ByVal requiredByteSize&)
        Dim numElements& = ubound - lbound + 1
        Dim itemSize& = LenB(Of T)
        
        Dim arrayCount& = ((requiredByteSize + itemSize - 1) / itemSize)
        If arrayCount < numElements Then arrayCount = numElements
                
        ReDim array(lbound To lbound + arrayCount - 1)
        Dim arrayAddr As LongPtr
        GetMemPtr(VarPtr(array), arrayAddr)
        
        SetCElements(ByVal arrayAddr, numElements)
        ' The SAFEARRAY structure's bounds reflect the number of elements.
        ' The allocated memory for the structure is potentially larger and can hold at 
        ' least requiredbyteSize bytes.
    End Sub
    
    Function AlignTo(ByVal ptr As LongPtr, ByVal alignment&) As LongPtr
        Return ((ptr + alignment& - 1) / alignment) * alignment
    End Function
    
    Sub InitStaticTrailingSA(ByVal data As LongPtr, ByVal elementSize&, ByVal count As LongPtr)
        Dim alignedSize As LongPtr = AlignTo(count * elementSize, 8)
        SetStaticSA(ByVal (data + alignedSize), elementSize, data, CLng(count))
    End Sub

    Function GetStaticTrailingSA(Of T)(ByVal data As LongPtr, ByVal count As LongPtr) As T()
        Dim alignedSize As LongPtr = AlignTo(count * LenB(Of T), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSA), data + alignedSize)
    End Function
    
    [Description("Allocates an area for data, followed by a trailing static SAFEARRAY describing it.")]
    Function AllocateArrayInUDT(ByVal newCount&, ByVal elementSize&, ByRef dataPtr As LongPtr, ByRef count&) As GpStatus
        Dim alignedSize As LongPtr
        
        If dataPtr <> 0 Then
            GdipFree(dataPtr)
            dataPtr = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize = AlignTo(newCount * elementSize, 8)
        dataPtr = GdipAlloc(alignedSize + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr = 0 Then
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr, elementSize, count)
        count = newCount
        Return Ok
    End Function
    
    [Description("Allocates two areas for data, each followed by a trailing static SAFEARRAY describing it.")]
    Function AllocateArraysInUDT(ByVal newCount&, ByVal elementSize1&, ByRef dataPtr1 As LongPtr, ByVal elementSize2&, ByRef dataPtr2 As LongPtr, ByRef count&) As GpStatus
        Dim alignedSize1 As LongPtr, alignedSize2 As LongPtr
                    
        If dataPtr1 <> 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
        End If
        If dataPtr2 <> 0 Then
            GdipFree(dataPtr2)
            dataPtr2 = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize1 = AlignTo(newCount * elementSize1, 8)
        dataPtr1 = GdipAlloc(alignedSize1 + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr1 = 0 Then Return OutOfMemory
        alignedSize2 = AlignTo(newCount * elementSize2, 8)
        dataPtr2 = GdipAlloc(alignedSize2 + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr2 = 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr1, elementSize1, count)
        InitStaticTrailingSA(dataPtr2, elementSize2, count)
        count = newCount
        Return Ok
    End Function

    Function GdipMin(ByVal a&, ByVal b&) As Long
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function
    
    Function GdipMin(ByVal a!, ByVal b!) As Single
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function

    Function GdipMin(ByVal a#, ByVal b#) As Double
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function
    
    Function GdipMin(ByVal a&, ByVal b&, ByVal c&) As Long
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function
    
    Function GdipMin(ByVal a!, ByVal b!, ByVal c!) As Single
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function

    Function GdipMin(ByVal a#, ByVal b#, ByVal c#) As Double
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function
    
    Function GdipMax(ByVal a&, ByVal b&) As Long
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a!, ByVal b!) As Single
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a#, ByVal b#) As Double
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a&, ByVal b&, ByVal c&) As Long
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function
    
    Function GdipMax(ByVal a!, ByVal b!, ByVal c!) As Single
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function
    
    Function GdipMax(ByVal a#, ByVal b#, ByVal c#) As Double
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function

    Sub RotateAtImpl(Of T)(ByVal obj As T, ByVal angle!, ByVal center As GpPointF, ByVal order As GpMatrixOrder = MatrixOrderPrepend)
        If order = MatrixOrderPrepend Then
            obj.TranslateTransform(center.X, center.Y, order)
            obj.RotateTransform(angle, order)
            obj.TranslateTransform(-center.X, -center.Y, order)
        Else
            obj.TranslateTransform(-center.X, -center.Y, order)
            obj.RotateTransform(angle, order)
            obj.TranslateTransform(center.X, center.Y, order)
        End If
    End Sub
    
    Public gdiPlusRefCount& = 0
    Public gdiPlusToken As GpToken
    
    Public GenericSansSerifFF As FontFamily
    Public GenericSerifFF As FontFamily
    Public GenericMonospaceFF As FontFamily
    
    Public Declare PtrSafe Function SafeArrayAllocDescriptor Lib "oleaut32" (ByVal cDims As Long, ppsaOut As Any) As Long
    
    [PreserveSig(False), UseGetLastError(False), DLLStackCheck(False)]
    [Description("")]
    Public DeclareWide PtrSafe Function vbaCopyBytesRef Lib "<hiddenmodule>" Alias "#16" (ByVal length As Long, dest As Any, src As Any) As LongPtr
End Module
