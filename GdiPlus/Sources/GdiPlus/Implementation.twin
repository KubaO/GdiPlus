' A part of the GDI+ Package for TwinBasic  https://github.com/kubao/GdiPlus
' Licensed under the MIT license. (c) 2026 Sunderland Ober Consulting.
' "Windows" is a trademark of the Microsoft Corporation.
' Modeled after code and descriptions (c) Microsoft, taken from SDK headers and official documentation.
' Certain flat API function and type declarations taken from WinDevLib by fafalone, with thanks.

Private Module GdipImplementation
    Private Const FADF_STATIC = &H2%
    Private Const FADF_FIXEDSIZE = &H10%

    Function ArrayLen(Of T)(array() As T) As Long
        Return 1 + UBound(array) - LBound(array)
    End Function
    
    Sub SetStaticSA(ByRef sa As SAFEARRAY1D, ByVal elementSize&, ByVal data As LongPtr, ByVal count&)
        sa.cDims = 1
        sa.fFeatures = FADF_STATIC + FADF_FIXEDSIZE
        sa.cbElements = elementSize&
        sa.cLocks = 0
        sa.pvData = data
        sa.Bounds.cElements = count
        sa.Bounds.lLbound = 1
    End Sub
    
    Private Sub SetCElements(ByRef sa As SAFEARRAY1D, ByVal count&)
        sa.Bounds.cElements = count
    End Sub
    
#If 1 Then
    [Description("Returns a static SAFEARRAY1D that refers to data.")]
    Function StaticSA(Of T)(ByVal data As LongPtr, ByVal count&) As T()
        Dim saPtr As LongPtr
        GdipImplementation.SafeArrayAllocDescriptor(1, StaticSA)
        GetMemPtr(VarPtr(StaticSA), saPtr)
        SetStaticSA(ByVal saPtr, LenB(Of T), data, count)
    End Function
#End If
    
#If 1 Then
    [Description("Redims an array from lbound to ubound." & vbcrlf & _
        "Ensures that total allocated size is at least requiredByteSize.")]
    Sub ReDimOversized(Of T)(array() As T, ByVal lbound&, ByVal ubound&, ByVal requiredByteSize&)
        Dim numElements& = ubound - lbound + 1
        Dim itemSize& = LenB(Of T)
        
        Dim arrayCount& = ((requiredByteSize + itemSize - 1) / itemSize)
        If arrayCount < numElements Then arrayCount = numElements
                
        ReDim array(lbound To lbound + arrayCount - 1)
        Dim arrayAddr As LongPtr
        GetMemPtr(VarPtr(array), arrayAddr)
        
        SetCElements(ByVal arrayAddr, numElements)
        ' The SAFEARRAY structure's bounds reflect the number of elements.
        ' The allocated memory for the structure is potentially larger and can hold at 
        ' least requiredbyteSize bytes.
    End Sub
#End If

#If 0 Then
    [Description("Redims an array from lbound to ubound." & vbcrlf & _
        "Ensures that total allocated size is at least requiredByteSize.")]
    Sub ReDimOversized(array() As ImageCodecInfo, ByVal lbound&, ByVal ubound&, ByVal requiredByteSize&)
        Dim numElements& = ubound - lbound + 1
        Dim itemSize& = LenB(Of ImageCodecInfo)
            
        Dim arrayCount& = ((requiredByteSize + itemSize - 1) / itemSize)
        If arrayCount < numElements Then arrayCount = numElements
                    
        ReDim array(lbound To lbound + arrayCount - 1)
        Dim arrayAddr As LongPtr
        GetMemPtr(VarPtr(array), arrayAddr)
            
        SetCElements(ByVal arrayAddr, numElements)
        ' The SAFEARRAY structure's bounds reflect the number of elements.
        ' The allocated memory for the structure is potentially larger and can hold at 
        ' least requiredbyteSize bytes.
    End Sub
#End If
    
    Function AlignTo(ByVal ptr As LongPtr, ByVal alignment&) As LongPtr
        Return ((ptr + alignment& - 1) / alignment) * alignment
    End Function
    
    Sub InitStaticTrailingSA(ByVal data As LongPtr, ByVal elementSize&, ByVal count&)
        Dim alignedSize& = AlignTo(count * elementSize, 8)
        SetStaticSA(ByVal (data + alignedSize), elementSize, data, count)
    End Sub
    
#If 1 Then
    Function GetStaticTrailingSA(Of T)(ByVal data As LongPtr, ByVal count&) As T()
        Dim alignedSize& = AlignTo(count * LenB(Of T), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSA), data + alignedSize)
    End Function
#End If
    
#If 0 Then
    Function GetStaticTrailingSAOfRECT(ByVal data As LongPtr, ByVal count&) As RECT()
        Dim alignedSize& = AlignTo(count * LenB(Of RECT), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSAOfRECT), data + alignedSize)
    End Function
    
    Function GetStaticTrailingSAOfByte(ByVal data As LongPtr, ByVal count&) As Byte()
        Dim alignedSize& = AlignTo(count * LenB(Of Byte), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSAOfByte), data + alignedSize)
    End Function
    
    Function GetStaticTrailingSAOfGpPointF(ByVal data As LongPtr, ByVal count&) As GpPointF()
        Dim alignedSize& = AlignTo(count * LenB(Of GpPointF), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSAOfGpPointF), data + alignedSize)
    End Function
#End If
    
    [Description("Allocates an area for data, followed by a trailing static SAFEARRAY describing it.")]
    Function AllocateArrayInUDT(ByVal newCount&, ByVal elementSize&, ByRef dataPtr As LongPtr, ByRef count As LongPtr) As GpStatus
        Dim alignedSize&
        
        If dataPtr <> 0 Then
            GdipFree(dataPtr)
            dataPtr = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize = AlignTo(newCount * elementSize, 8)
        dataPtr = GdipAlloc(alignedSize + LenB(Of SAFEARRAY1D))
        If dataPtr = 0 Then
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr, elementSize, count)
        count = newCount
        Return Ok
    End Function
    
    [Description("Allocates two areas for data, each followed by a trailing static SAFEARRAY describing it.")]
    Function AllocateArraysInUDT(ByVal newCount&, ByVal elementSize1&, ByRef dataPtr1 As LongPtr, ByVal elementSize2&, ByRef dataPtr2 As LongPtr, ByRef count As LongPtr) As GpStatus
        Dim alignedSize1&, alignedSize2&
                    
        If dataPtr1 <> 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
        End If
        If dataPtr2 <> 0 Then
            GdipFree(dataPtr2)
            dataPtr2 = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize1 = AlignTo(newCount * elementSize1, 8)
        dataPtr1 = GdipAlloc(alignedSize1 + LenB(Of SAFEARRAY1D))
        If dataPtr1 = 0 Then Return OutOfMemory
        alignedSize2 = AlignTo(newCount * elementSize2, 8)
        dataPtr2 = GdipAlloc(alignedSize2 + LenB(Of SAFEARRAY1D))
        If dataPtr2 = 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr1, elementSize1, count)
        InitStaticTrailingSA(dataPtr2, elementSize2, count)
        count = newCount
        Return Ok
    End Function
    
    Public gdiPlusRefCount& = 0
    Public gdiPlusToken& = -1
    
    Public Declare PtrSafe Function SafeArrayAllocDescriptor Lib "oleaut32" (ByVal cDims As Long, ppsaOut As LongPtr) As Long
    
    [PreserveSig(False), UseGetLastError(False), DLLStackCheck(False)]
    [Description("")]
    Public DeclareWide PtrSafe Function vbaCopyBytesRef Lib "<hiddenmodule>" Alias "#16" (ByVal length As Long, dest As Any, src As Any) As LongPtr
End Module
