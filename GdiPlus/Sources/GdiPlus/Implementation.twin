' A part of the GDI+ Package for TwinBasic  https://github.com/kubao/GdiPlus
' Licensed under the MIT license. (c) 2026 Sunderland Ober Consulting.
' "Windows" is a trademark of the Microsoft Corporation.
' Modeled after code and descriptions (c) Microsoft, taken from SDK headers and official documentation.
' Certain flat API function and type declarations taken from WinDevLib by fafalone, with thanks.

Private Module GdipImplementation
    Private Const FADF_STATIC = &H2%
    Private Const FADF_FIXEDSIZE = &H10%

    Function ArrayLen(Of T)(array() As T) As Long
        Return 1 + UBound(array) - LBound(array)
    End Function
    
    [Description("Sets sa to be a 1D static view into data. Existing value of sa, if any, is discarded." & vbCrLf _
        & "If sa was previously pointing to dynamically allocated data, that memory will be leaked.")]
    Sub SetStaticSA(ByRef sa As GDIP_SAFEARRAY1D, ByVal elementSize&, ByVal data As LongPtr, ByVal count&)
        sa.cDims = 1
        sa.fFeatures = FADF_STATIC + FADF_FIXEDSIZE
        sa.cbElements = elementSize&
        sa.cLocks = 0
        sa.pvData = data
        sa.Bounds.cElements = count
        sa.Bounds.lLbound = 1
    End Sub
    
    Private Sub SetCElements(ByRef sa As GDIP_SAFEARRAY1D, ByVal count&)
        sa.Bounds.cElements = count
    End Sub
    
    [Description("Returns a static 1D view of data.")]
    Function StaticSA(Of T)(ByVal data As LongPtr, ByVal count&) As T()
        Dim saPtr As LongPtr
        GdipImplementation.SafeArrayAllocDescriptor(1, StaticSA)
        GetMemPtr(VarPtr(StaticSA), saPtr)
        SetStaticSA(ByVal saPtr, LenB(Of T), data, count)
    End Function

    [Description("Redims an array from lbound to ubound." & vbCrLf & _
        "Ensures that total allocated size is at least requiredByteSize.")]
    Sub ReDimOversized(Of T)(array() As T, ByVal lbound&, ByVal ubound&, ByVal requiredByteSize&)
        Dim numElements& = ubound - lbound + 1
        Dim itemSize& = LenB(Of T)
        
        Dim arrayCount& = ((requiredByteSize + itemSize - 1) / itemSize)
        If arrayCount < numElements Then arrayCount = numElements
                
        ReDim array(lbound To lbound + arrayCount - 1)
        Dim arrayAddr As LongPtr
        GetMemPtr(VarPtr(array), arrayAddr)
        
        SetCElements(ByVal arrayAddr, numElements)
        ' The SAFEARRAY structure's bounds reflect the number of elements.
        ' The allocated memory for the structure is potentially larger and can hold at 
        ' least requiredByteSize bytes.
    End Sub
    
    Function AlignTo(ByVal ptr As LongPtr, ByVal alignment&) As LongPtr
        Return ((ptr + alignment& - 1) / alignment) * alignment
    End Function
    
    [Description("Sets up a static 1D view of data in the same allocation as the data." & vbCrLf _
        & "Assumes that there is enough extra space after the data to fit a STATICARRAY1D header." & vbCrLf _
        & "Does not allocate memory.")]
    Sub InitStaticTrailingSA(ByVal data As LongPtr, ByVal elementSize&, ByVal count As LongPtr)
        Dim alignedSize As LongPtr = AlignTo(count * elementSize, 8)
        SetStaticSA(ByVal (data + alignedSize), elementSize, data, CLng(count))
    End Sub
    
    [Description("Returs the static 1D view of data that was previously set up using InitStaticTrailingSA." & vbCrLf _
        & "Does not allocate memory.")]
    Function GetStaticTrailingSA(Of T)(ByVal data As LongPtr, ByVal count As LongPtr) As T()
        Dim alignedSize As LongPtr = AlignTo(count * LenB(Of T), 8)
        PutMemPtr(VarPtr(GetStaticTrailingSA), data + alignedSize)
    End Function
    
    [Description("Allocates an area for data, followed by a trailing static SAFEARRAY describing it." & vbCrLf _
        & "The allocation is done using GdipAlloc. Any existing data is first freed using GdipFree.")]
    Function AllocateArrayInUDT(ByVal newCount&, ByVal elementSize&, ByRef dataPtr As LongPtr, ByRef count&) As GpStatus
        Dim alignedSize As LongPtr
        
        If dataPtr <> 0 Then
            GdipFree(dataPtr)
            dataPtr = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize = AlignTo(newCount * elementSize, 8)
        dataPtr = GdipAlloc(alignedSize + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr = 0 Then
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr, elementSize, count)
        count = newCount
        Return Ok
    End Function
    
    [Description("Allocates two areas for data, or equal number of elements, each followed by a trailing static SAFEARRAY1D describing it." & vbCrLf _
        & "The allocation is done using GdipAlloc. Any existing data is first freed using GdipFree.")]
    Function AllocateArraysInUDT(ByVal newCount&, ByVal elementSize1&, ByRef dataPtr1 As LongPtr, ByVal elementSize2&, ByRef dataPtr2 As LongPtr, ByRef count&) As GpStatus
        Dim alignedSize1 As LongPtr, alignedSize2 As LongPtr
                    
        If dataPtr1 <> 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
        End If
        If dataPtr2 <> 0 Then
            GdipFree(dataPtr2)
            dataPtr2 = 0
        End If
        count = 0
        If newCount = 0 Then Return Ok
        alignedSize1 = AlignTo(newCount * elementSize1, 8)
        dataPtr1 = GdipAlloc(alignedSize1 + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr1 = 0 Then Return OutOfMemory
        alignedSize2 = AlignTo(newCount * elementSize2, 8)
        dataPtr2 = GdipAlloc(alignedSize2 + LenB(Of GDIP_SAFEARRAY1D))
        If dataPtr2 = 0 Then
            GdipFree(dataPtr1)
            dataPtr1 = 0
            Return OutOfMemory
        End If
        InitStaticTrailingSA(dataPtr1, elementSize1, count)
        InitStaticTrailingSA(dataPtr2, elementSize2, count)
        count = newCount
        Return Ok
    End Function
    
    Function SetFlag(Of T)(ByVal flags As T, ByVal flag As T, ByVal value As Boolean) As T
        Return If(value, flags Or flag, flags And (Not flag))
    End Function

    Function GdipMin(ByVal a&, ByVal b&) As Long
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function
    
    Function GdipMin(ByVal a!, ByVal b!) As Single
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function

    Function GdipMin(ByVal a#, ByVal b#) As Double
        GdipMin = a
        If b < GdipMin Then GdipMin = b
    End Function
    
    Function GdipMin(ByVal a&, ByVal b&, ByVal c&) As Long
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function
    
    Function GdipMin(ByVal a!, ByVal b!, ByVal c!) As Single
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function

    Function GdipMin(ByVal a#, ByVal b#, ByVal c#) As Double
        GdipMin = a
        If b < GdipMin Then GdipMin = b
        If c < GdipMin Then GdipMin = c
    End Function
    
    Function GdipMax(ByVal a&, ByVal b&) As Long
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a!, ByVal b!) As Single
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a#, ByVal b#) As Double
        GdipMax = a
        If b > GdipMax Then GdipMax = b
    End Function
    
    Function GdipMax(ByVal a&, ByVal b&, ByVal c&) As Long
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function
    
    Function GdipMax(ByVal a!, ByVal b!, ByVal c!) As Single
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function
    
    Function GdipMax(ByVal a#, ByVal b#, ByVal c#) As Double
        GdipMax = a
        If b > GdipMax Then GdipMax = b
        If c > GdipMax Then GdipMax = c
    End Function
    
    [DebugOnly]
    Sub CheckModS()
        Debug.Print GdipModS(0, 100), GdipModS(10, 100), GdipModS(99, 100), GdipModS(100, 100), GdipModS(599, 100)
        Debug.Print GdipModS(-0, 100), GdipModS(-10, 100), GdipModS(-99, 100), GdipModS(-100, 100), GdipModS(-599, 100)
    End Sub
    
    [Description("Modulo, but floating point")]
    Function GdipModS(ByVal a!, ByVal by!) As Single
        Return a - (CLngLng(a / by) * by)
    End Function
    
    [Description("Modulo, but floating point")]
    Function GdipModD(ByVal a#, ByVal by#) As Single
        Return a - (CLng(a / by) * by)
    End Function

    Function GdipLimitL(ByVal min&, ByVal val&, ByVal max&) As Long
        If val < min Then Return min
        If val > max Then Return max
        Return val
    End Function
    
    Function GdipLimitS(ByVal min!, ByVal val!, ByVal max!) As Single
        If val < min Then Return min
        If val > max Then Return max
        Return val
    End Function
    
    Function GdipLimitD(ByVal min#, ByVal val#, ByVal max#) As Double
        If val < min Then Return min
        If val > max Then Return max
        Return val
    End Function

    Sub RotateAtImpl(Of T)(ByVal obj As T, ByVal angle!, ByVal center As GpPointF, ByVal order As GpMatrixOrder = MatrixOrderPrepend)
        If order = MatrixOrderPrepend Then
            obj.TranslateTransform(center.X, center.Y, order)
            obj.RotateTransform(angle, order)
            obj.TranslateTransform(-center.X, -center.Y, order)
        Else
            obj.TranslateTransform(-center.X, -center.Y, order)
            obj.RotateTransform(angle, order)
            obj.TranslateTransform(center.X, center.Y, order)
        End If
    End Sub
    
    Public gdiPlusRefCount& = 0
    Public gdiPlusToken As GpToken
    
    Public GenericSansSerifFF As FontFamily
    Public GenericSerifFF As FontFamily
    Public GenericMonospaceFF As FontFamily
    
    Public Declare PtrSafe Function SafeArrayAllocDescriptor Lib "oleaut32" (ByVal cDims As Long, ppsaOut As Any) As Long
    
    [PreserveSig(False), UseGetLastError(False), DLLStackCheck(False)]
    [Description("")]
    Public DeclareWide PtrSafe Function vbaCopyBytesRef Lib "<hiddenmodule>" Alias "#16" (ByVal length As Long, dest As Any, src As Any) As LongPtr
End Module
