Module ModMain
    Dim pBrush As SolidBrush
    Dim pPen As Pen
    Dim pFont As Font
    Dim pFormat As StringFormat
    Const tickMS% = 5
    
    Sub Main()
        Dim user As Any = GdiPlusUser()
        Dim class As GDIP_WNDCLASS
        
        Set pBrush = SolidBrush(White)
        Set pPen = Pen(0)
        Set pFont = Font(GenericSansSerif(), 10)
        Set pFormat = StringFormat()
        
        With class
            .style = CS_HREDRAW Or CS_VREDRAW
            .hInstance = GetModuleHandle()
            .hbrBackground = 0
            .hCursor = LoadCursor(0, IDC_ARROW)
            .lpszClassName = StrPtr("AnalogClock")
            .lpfnWndProc = AddressOf WndProc
        End With
        
        timeBeginPeriod(tickMS)
        RegisterClass(class)
        BufferedPaintInit()
        
        Dim hWnd As LongPtr = CreateWindowEx( _
                0, "AnalogClock", "Analog Clock", _
                WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 1000, 1050, _
                0, 0, GetModuleHandle(), 0)

        ShowWindow(hWnd, SW_SHOWNORMAL)
        UpdateWindow(hWnd)
        
        Dim msg As GDIP_MSG
        While GetMessage(msg, 0, 0, 0)
            TranslateMessage(msg)
            DispatchMessage(msg)
        Wend

        timeEndPeriod(tickMS)
        BufferedPaintUnInit()
        UnregisterClass(class.lpszClassName)
        
        Set pBrush = Nothing
        Set pPen = Nothing
        Set pFont = Nothing
        Set pFormat = Nothing
        Set user = Nothing
    End Sub
    
    Function Timer() As Single
        Dim st As GDIP_SYSTEMTIME
        GetLocalTime(st)
        Return st.wHour * 3600.0 + st.wMinute * 60.0 + st.wSecond + st.wMilliseconds * 0.001
    End Function
    
    Sub Draw(gr As Graphics, rect As GpRectF)
        Dim side! = If(rect.Width > rect.Height, rect.Height, rect.Width)
        Dim tSeconds! = Timer
        Dim time$
        Dim i%, phi!
        
        pBrush.RGB = White
        If rect.Width > side Then
            gr.FillRectangle(pBrush, 0, 0, (rect.Width - side) / 2 + 1, rect.Height)
            gr.FillRectangle(pBrush, (rect.Width + side) / 2 - 1, 0, (rect.Width - side) / 2 + 2, rect.Height)
        Else
            gr.FillRectangle(pBrush, 0, 0, rect.Width, (rect.Height - side) / 2 + 1)
            gr.FillRectangle(pBrush, 0, (rect.Height + side) / 2 - 1, rect.Width, (rect.Height - side) / 2 + 2)
        End If
        
        gr.TranslateTransform((rect.Width - side) / 2, (rect.Height - side) / 2)
        
        pBrush.RGB = White
        gr.SmoothingMode = SmoothingModeAntiAlias
        gr.FillRectangle(pBrush, 0, 0, side, side)
        
        ' Set drawing area to be -100, -100 to 100, 100
        gr.TranslateTransform(side / 2, side / 2)
        gr.ScaleTransform(side / 200, side / 200)
        
        ' Face
        pBrush.RGB = Coral
        gr.FillEllipse(pBrush, -100, -100, 200, 200)
        pBrush.RGB = LightCoral
        gr.FillEllipse(pBrush, -92, -92, 184, 184)
        
        ' Datum
        pPen.Set(Red, 0.5)
        gr.RotateTransform(-90)
        gr.DrawLine(pPen, 0, 0, 100, 0)
        
        ' Minute Ticks
        pPen.Set(LightGray, 3)
        For i = 1 To 60
            gr.DrawLine(pPen, 88, 0, 95, 0)
            gr.RotateTransform(360 / 60)
        Next
        
        ' Hour Ticks
        pPen.Set(DarkGray, 4)
        For i = 1 To 12
            gr.DrawLine(pPen, 80, 0, 95, 0)
            gr.RotateTransform(360 / 12)
        Next
        
        ' Time
        pBrush.RGB = Black
        pFormat.Alignment = StringAlignmentCenter
        time = Format(Int(tSeconds / 3600) Mod 24, "00") & ":" & _
            Format(Int(tSeconds / 60) Mod 60, "00") & ":" & _
            Format(Int(tSeconds / 1) Mod 60, "00") & "." & _
            Format(Int(tSeconds * 10) Mod 10, "0")
        gr.RotateTransform(90)
        gr.DrawString(time, pFont, 0!, 40!, pFormat, pBrush)
        gr.RotateTransform(-90)
        
        pPen.Set(Black, 1)
        pBrush.RGB = LightGray
        
        ' Hours Arm
        phi = (tSeconds / 3600) * 360 / 12
        gr.RotateTransform(phi)
        gr.FillRectangle(pBrush, -5, -4, 65, 8)
        gr.DrawRectangle(pPen, -5, -4, 65, 8)
        gr.RotateTransform(-phi)
        
        ' Minutes Arm
        phi = (tSeconds / 60) * 360 / 60
        gr.RotateTransform(phi)
        gr.FillRectangle(pBrush, -8, -2, 85, 2)
        gr.DrawRectangle(pPen, -8, -2, 85, 2)
        gr.RotateTransform(-phi)
        
        ' Seconds Arm
        phi = (tSeconds) * 360 / 60
        gr.RotateTransform(phi)
        pPen.RGB = Black
        gr.DrawLine(pPen, -10, 0, 100, 0)
    End Sub
    
    Sub Paint(ByVal hWnd As LongPtr, wndRect As GDIP_RECT)
        Dim rect As GpRectF
        rect.SetFromRECT(wndRect)

        Dim gr As Any = BufferedGraphicsFromHWND(hWnd)
        Draw(gr, rect)
    End Sub
    
    Function ClientRect(hWnd As LongPtr) As GpRect
        Dim rect As GDIP_RECT
        GetClientRect(hWnd, rect)
        Return GpRect(rect)
    End Function
    
    Function WndProc(ByVal hWnd&, ByVal message&, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
        Dim rect As GDIP_RECT
        Select Case message
            Case WM_CREATE
                SetTimer(hWnd, 0, tickMS, 0)
            Case WM_ERASEBKGND
                Return True
            Case WM_SIZE
                GetClientRect(hWnd, rect)
                InvalidateRect(hWnd, rect, False)
            Case WM_PAINT
                GetClientRect(hWnd, rect)
                Paint(hWnd, rect)
            Case WM_TIMER
                GetClientRect(hWnd, rect)
                InvalidateRect(hWnd, rect, False)
            Case WM_DESTROY:
                PostQuitMessage(0)
            Case Else
                Return DefWindowProc(hWnd, message, wParam, lParam)
        End Select
    End Function
End Module
